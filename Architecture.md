# Architecture of Uperf
As stated in the [documentation](http://uperf.org/manual.html) uperf is a file based network micro benchmark utility. The goal of this document is to provide a developer with an overview of the file layout, control flow, and data structures. In addition to this document is the [design_notes](manual/design_notes.txt) file which lays out additional information.

## Glossary
- **strand** - uperf abstraction for process or pthread
- **flowop** - the smallest unit of work specified in a XML configuration file, including `connect`,`read`,`write`, and `disconnect`.
- **transaction** - wrapper around one or more flowops
- **group** - a set of transaction that can be executed by one or more threads
- **client** - acts a client in the client server model, also responsible for stats collection and transmitting the work to be done to the server.
- **server** - a simple daemon that receives packets from the client, keeps track of the stats of the run, and transmits stats back to the client.

# CodeMap
A brief description of the purpose of the files
## `common.[c|h]`
Functions and structures that are common to the client and server
## `delay.[c|h]`
Functions used when needing to sleep or spin wait.
## `execute.[c|h]`
A wrapper around the transactions that are specified by the user.
## `flowops.[c|h]`
Structures and enums that define the results and error generated by flowops.
## `generic.[c|h]`
Layer that sits on top of all protocols to facilitate open,send,close operations.
## `goodbye.[c|h]`
Structures and functions covering the last message from the server to the client. The purpose of the message is to transmit the collected statistics from the run to the client.
## `handshake.[c|h]`
Functions that handle the sending and receiving of the groups, transactions, and flowops.
## `hwcounter.c`
Uses `sys/systeminfo.h`, and `sysinfo` function. By default looks for `BU_cpu_clk_unhalted` and `FR_retired_x86_instr_w_excp_intr`.
## `logging.[c|h]`
Provides 6 message types, `ERROR`,`QUIT`,`ABORT`,`INFO`,`DEBUG`,`WARN`. Logs to stdout by default.
## `netstat.[c|h]`
On Linux, this parses `/proc/net/dev`.
## `numbers.[c|h]`
Utility functions to convert numbers to be human readable.
## `parse.[c|h]`
Parses the XML based configuration file
## `print.[c|h]`
Window width aware printer for run time and summary stats
## `protocol.[c|h]`
Abstraction layer that sits on top of supported protocols, allowing de-coupling of protocol implementations and the uperf benchmark harness.
## `rate.[c|h]`
Functions that will execute a supplied callback at the rate given in the function declaration.
## `stats.[c|h]`
Functions and data structures covering statistics and data collection. Collection is done in shared memory.
## `strand.[c|h]`
Abstraction layer meant to abstract threads and processes so they can both be controlled via these functions.
## `sync.[c|h]`
Functions and structures to ensure that all strands complete a transaction before moving onto the next transaction


## Data Structures
As seen in the [design notes](manual/design_notes.txt)

* barriers
* global error
* slave list
  * name
  * port
  * control connection
* Workorder
* strand_state_summary
* per-strand structures
  * array of stat_t
  * per_strand state
  * slave list
    * connection array
  * strand_id
  * buffer
  * hardware counter structure


## Adding a new flowop type
As seen in the [design notes](manual/design_notes.txt)

1. Update `flowop_type_t` in flowops.h
2. Update flowops[] to add new flowop
3. Update `opp_flowopspp[]`
3. Implement the flowop stub in `flowops_library.c`
4. Update `flowop_get_execute_func()` in `flowops_library.c`
6. Update the protocol structure to add the new flowop
7. Implement the flowop for each protocol

# Basic Flow of Master and Slave
## Master

1. Parse workload profile
2. For each unique remote host
 * handshake start
 * workorder transfer
 * send port numbers (for ex if master has to do accept())
 * get port numbers (used when master needs to connect())
 * get confirmation that all remote strands started
 * handshake end
3. Create per strand data structures
  * Init barriers
4. Create strands
  * send handshake_end message to slave
  * open begin_run barrier
5. Wait for strands to finish
6. Statistics gathering/reporting

## Slave

1. Wait for connection, fork to handle it.
2. Communicate with master
  * handshake_begin
  * get workorder
  * get ports
  * byteswap if necessary
  * create per thread data structures
  * create strands with handle to workorder
3. Wait for handshake_end msg from master
4. Reply with confirmation that strands have started
5. Open begin_run barrier
6. Wait for strands to finish


